{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)5958a7c4-4190-4632-9e8d-a0514bb4166b","ParentGuid":"(Guid)424dd9f0-284c-44c2-ab5a-30cc48b07b83","Name":"(string)CheckPointer","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)24568a24-c491-472c-a21f-ee5d33859fab","@Value":{"@Type":"24568a24","@Value":{"MemoryReserveForOnlineChange":"(int)0","ExcludeFromBuild":"(bool)False","External":"(bool)False","EnableSystemCall":"(bool)False","CompilerDefines":"(string)","LinkAlways":"(bool)False","Undefines":{"@Type":"[string]","@Value":[]}}}},{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)1a3156da-39ac-4296-b00e-4a8ef5917276"}]}}}}]},"TypeGuid":"(Guid)c3fc9989-e24b-4002-a2c7-827a0a2595f4","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"24568a24":"{24568a24-c491-472c-a21f-ee5d33859fab}","2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","bool":"System.Boolean","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","int":"System.Int32","string":"System.String"}},"object":{"Graph":{"@Type":"c3fc9989","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)IF ptToTest = 0 THEN //Just check NULL-Pointer\n\n  IF bWrite THEN // write access\n    strError:='CheckPointer: Invalid write-access to 16#0';\n  ELSE\n    strError:='CheckPointer: Invalid read-access to 16#0';\n  END_IF\n  strError:=CONCAT(STR1:=strError  , STR2:= ' - Size: ');\n  strError:=CONCAT(STR1:=strError  , STR2:=TO_STRING(iSize));\n  strError:=CONCAT(STR1:=strError  , STR2:=' - See callstack for reason!');\n  \n  LogAdd2(hLogger:= CmpLog.LOG_STD_LOGGER,udiCmpID:= 16#1000,udiClassID:= LogClass.LOG_ERROR,udiErrorID:= 1,udiInfoID:= 1,pszInfo:= strError);\n  //  Triggering an access violation --> Application will be stopped\n  //  Sporadically, this default error reaction has to be adjusted to the application. \n  //  For example, stopping of the application can be invalid and can result in complicated recommissioning or even injury to people or damage to machines.\n  //  Thus, adjust the default error reaction to your application.\n  ptNull^ := 0; //Triggering an access violation \n\t\nELSE // pointer is not a NULL-Pointer\n\tCheckPointer := ptToTest; \nEND_IF\n","LineInfoPersistence":"(string)5958a7c4-4190-4632-9e8d-a0514bb4166b_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)// Short description:      Test function to increase machine safety by detecting unauthorized accesses via POINTER and REFERENCE variables\n//\n// Functional description: This function is implicitly called prior to each pointer access and verifies if the access is invalid to 0.\n//                         If the access is authorized, the function returns the pointer to the calling POU and the access is completed.\n//                         If the access is unauthorized, an exception is triggered as default error reaction. This exception results in an application stop and the system is set to safe state. \n//                         It is recommended to adapt an appropriate error response to the machine application.\n//   \n// Handling particularities: Sporadically, the implemented default error reaction has to be adjusted to the application. \n//                           For example, stopping of the application can be invalid and can result in complicated recommissioning or even injury to people or damage to machines.\n//                           Thus, adjust the default error reaction to your application.\n//                           After inserting/removing this function in/from the project, no online change is possible.\n//                           A complete download is required.\n//                         \n// Further information:    The implicit calls of this check function are realized in all POUs but not in POUs of protected (*.compiled library) \n//                         and open (*.library) libraries or in POUs with the attribute {attribute 'no_check'}. Consequently, they do not increase the runtime.\n//                         If the check is also to be performed in open libraries, enter the compiler definition \n//                         checks_in_libs in the field Compiler-Defines of the Build tab in the property dialog of the application node.\n//                         An increased runtime depends on the number of programmed pointer accesses or the use of REFERENCE variables.\n//                         \n//                         To reduce task runtimes, add the attribute 'no_check' to the POUs. \n//                         Checks performed by the check functions (CheckPointer, CheckBounds, CheckDiv, CheckRange) are not performed in these POUs. \n//                         Thus, these POUs have to be checked by the user regarding pointer programming, divisions and array accesses.  \n//                         For more information, refer to the F1-help.\n//                         \n//                         In the standard implementation, it is checked if the pointer access takes place to Adress 16#0 (NULL-Pointer).\n//                         In this case, check the callstack (menu Debug/Callstack) and change the incorrect logic.\n//                         \n//                         If your application is not time-critical, use this function during commissioning as well as during the production phase of the machine.\n//                         Only remove this function if you are sure that your user code is free from errors!\n//\n// Do not change the declaration of this function! Add only local variables.  \n// Do not change the attributes above the function header!\n{attribute 'check_pointer'}\n{attribute 'signature_flag' := '1073741824'}\n{attribute 'no_check'}\nFUNCTION CheckPointer : POINTER TO BYTE\nVAR_INPUT \n  ptToTest : POINTER TO BYTE; // Pointer target address\n  iSize : DINT;\t\t            // Size of the type to which the pointer points. (z.B.: 20 für POINTER TO ARRAY [1..10] OF WORD) \n  iGran : DINT;\t\t            // Granularity of the pointer access. This is the size of the largest unstructured data type in the type to which the pointer points. \n                                // (e.g.: 2 for POINTER TO ARRAY [0..9] OF INT).\n  bWrite: BOOL;\t\t            // Indicates read or write access. TRUE = write access.\nEND_VAR\nVAR\n  ptNull:   POINTER TO BYTE := 0; // Nullpointer for triggering an access violation\n  strError: STRING(128);          // Diagnostic text for the PLC logger entry\n  i: INT;\t\t\t\t\t\t              // Index variable\nEND_VAR","LineInfoPersistence":"(string)5958a7c4-4190-4632-9e8d-a0514bb4166b_Decl_LineIds"}}}},"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"CheckPointer"}}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","c3fc9989":"{c3fc9989-e24b-4002-a2c7-827a0a2595f4}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}