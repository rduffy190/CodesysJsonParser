{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)5c57242d-0abc-44e9-a367-983e29473911","ParentGuid":"(Guid)424dd9f0-284c-44c2-ab5a-30cc48b07b83","Name":"(string)CheckBounds","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)24568a24-c491-472c-a21f-ee5d33859fab","@Value":{"@Type":"24568a24","@Value":{"MemoryReserveForOnlineChange":"(int)0","ExcludeFromBuild":"(bool)False","External":"(bool)False","EnableSystemCall":"(bool)False","CompilerDefines":"(string)","LinkAlways":"(bool)False","Undefines":{"@Type":"[string]","@Value":[]}}}},{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)1a3156da-39ac-4296-b00e-4a8ef5917276"}]}}}}]},"TypeGuid":"(Guid)c3fc9989-e24b-4002-a2c7-827a0a2595f4","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"24568a24":"{24568a24-c491-472c-a21f-ee5d33859fab}","2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","bool":"System.Boolean","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","int":"System.Int32","string":"System.String"}},"object":{"Graph":{"@Type":"c3fc9989","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)    (*****************************************************************************************************)\n    (* The implementation has to be adjusted to your application/machine.                                *)\n    (* This is an exemplary implementation of the function.                                              *)\n    (* Per default, an access violation is generated in case of an faulty acces to avoid machine damage. *)\n    (* In this case, check the Call Stack (menu Debug/Callstack) and modify the faulty logic.            *)\n    (*****************************************************************************************************)\n\nIF  index < lower THEN \n  strError:= 'CheckBounds: Lower arrayindex ';\n  strError:=CONCAT(STR1:=strError  , STR2:= DINT_TO_STRING(lower));\n  strError:=CONCAT(STR1:=strError  , STR2:= ' underrunned by ');\n  strError:=CONCAT(STR1:=strError  , STR2:= DINT_TO_STRING(index));\n//  Default implementation for APPLICATION WILL BE STOPPED: \n//  Set an error into the plc logger\n  LogAdd2(hLogger:= CmpLog.LOG_STD_LOGGER,udiCmpID:= 16#1000,udiClassID:= LogClass.LOG_ERROR,udiErrorID:= 1,udiInfoID:= 1,pszInfo:= strError);\n//  Triggering an access violation --> Application will be stopped\n  ptNull^ := 0;(* Triggering an access violation *)\n\n// // Example for APPLICATION WILL NOT BE STOPPED:\n// // Limit the faulty index to the lower index \n// //     --> no memory will be overwritten\n// //     --> Keep PLC-task running\n// // Set a warning into the plc logger\n// // NOTE: There is still an implementation error in your application code!\n// //  LogAdd2(hLogger:= CmpLog.LOG_STD_LOGGER,udiCmpID:= 16#1000,udiClassID:= LogClass.LOG_WARNING,udiErrorID:= 1,udiInfoID:= 1,pszInfo:= strError);\n// // \n//  CheckBounds := lower; //access to the lower index only \n//  return;\n\nELSIF  index > upper THEN\n  strError:= 'CheckBounds: Higher arrayindex ';\n  strError:=CONCAT(STR1:=strError  , STR2:= DINT_TO_STRING(upper));\n  strError:=CONCAT(STR1:=strError  , STR2:= ' overrunned by ');\n  strError:=CONCAT(STR1:=strError  , STR2:= DINT_TO_STRING(index));\n\n//  Default implementation for APPLICATION WILL BE STOPPED: \n//  Set an error into the plc logger\n  LogAdd2(hLogger:= CmpLog.LOG_STD_LOGGER,udiCmpID:= 16#1000,udiClassID:= LogClass.LOG_ERROR,udiErrorID:= 1,udiInfoID:= 1,pszInfo:= strError);\n//  Triggering an access violation --> Application will be stopped\n  ptNull^ := 0;(* Triggering an access violation *)\n\n// // Example for APPLICATION WILL NOT BE STOPPED:\n// // Limit the faulty index to the upper index \n// //     --> no memory will be overwritten\n// //     --> Keep PLC-task running\n// // Set a warning into the plc logger\n// // NOTE: There is still an implementation error in your application code!\n//  LogAdd2(hLogger:= CmpLog.LOG_STD_LOGGER,udiCmpID:= 16#1000,udiClassID:= LogClass.LOG_WARNING,udiErrorID:= 1,udiInfoID:= 1,pszInfo:= strError);\n// \n//  CheckBounds := upper; //access to the upper index only \n//  return;\n\nELSE // access to array is within lower and upper index --> ok  \n  CheckBounds := index;\nEND_IF\n","LineInfoPersistence":"(string)5c57242d-0abc-44e9-a367-983e29473911_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)// Short description:      Test function to increase machine safety by checking for unauthorized array indices accesses.\n// \n// Functional description: This function is implicitly called prior to each array access and verifies if the access is within the valid array bounds.\n//                         If the access is authorized, the function returns the index to the calling POU and the access is completed.\n//                         If the access is unauthorized, an exception is triggered as default error reaction. This exception results in an application stop and the system is set to safe state. \n//   \n// Handling particularities: Sporadically, the implemented default error reaction has TO be adjusted TO the application. \n//                           For example, stopping of the application can be invalid and can result in complicated recommissioning or even injury to people or damage to machines.\n//                           Thus, adjust the default error reaction to your application.\n//                           After inserting/removing this function in/from the project, no online change is possible.\n//                           A complete download is required.\n// \n// Further information:    The implicit calls of this check function are realized in all POUs but not in POUs of protected (*.compiled library) \n//                         and open (*.library) libraries or in POUs with the attribute {attribute 'no_check'}. Consequently, they do not increase the runtime.\n//                         If the check is also to be performed in open libraries, enter the compiler definition \n//                         checks_in_libs in the field Compiler-Defines of the Build tab in the property dialog of the application node.\n//                         An increased runtime depends on the number of programmed array accesses.\n// \n//                         To reduce task runtimes, add the attribute 'no_check' to the POUs. \n//                         Checks performed by the check functions (CheckPointer, CheckBounds, CheckDiv, CheckRange) are not performed in these POUs. \n//                         Thus, these POUs have to be checked by the user regarding pointer programming, divisions and array accesses.  \n//                         For more information, refer to the F1-help.\n// \n//                         In the standard implementation, it is checked if the array access takes place within the valid array boundaries.\n// \n//                         In case of invalid access (outside the valid array boundaries), an error is entered in the PLC logger and the application is stopped to avoid injury to persons and damage to machines.\n//                         In this case, check the callstack (menu Debug/Callstack) and change the incorrect logic.\n//\n//                         If your application is not time-critical, use this function during commissioning as well as during the production phase of the machine.\n//                         Only remove this function if you are sure that your user code is free from errors!\n// \n// Do not change the declaration of this function! Add only local variables.  \n// Do not change the attributes above the function header!\n{attribute 'check_bounds'}\n{attribute 'no_check'}\n{attribute 'signature_flag' := '1073741824'}\nFUNCTION CheckBounds : DINT\nVAR_INPUT\n  index, lower, upper: DINT;   // Index of the array, lower bound and upper bound\nEND_VAR\nVAR\n  ptNull: POINTER TO BYTE :=0; // Nullpointer for triggering an access violation\n  strError: STRING;            // Diagnostic text for the PLC logger entry\nEND_VAR","LineInfoPersistence":"(string)5c57242d-0abc-44e9-a367-983e29473911_Decl_LineIds"}}}},"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"CheckBounds"}}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","c3fc9989":"{c3fc9989-e24b-4002-a2c7-827a0a2595f4}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}