{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)6c12f7bf-0d38-403a-9f81-0c4bb214fb91","ParentGuid":"(Guid)424dd9f0-284c-44c2-ab5a-30cc48b07b83","Name":"(string)JsonHadlr","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)6656192e-8d5a-404e-a5bf-0eede4dc143d"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)// Initialize result\nResult.DataType := JSON_DATA_NULL;\nResult.pValue := 0;\n\n// Get pointer to start of token\npTokenStart := pJsonString + TO_LWORD(Token.StartIndex);\n\n// Parse based on token type\nCASE Token.TokenType OF\n    \n    JSON_TOKEN_NULL:\n        Result.DataType := JSON_DATA_NULL;\n        Result.pValue := 0;\n    \n    JSON_TOKEN_TRUE, JSON_TOKEN_FALSE:\n        // Allocate memory for boolean\n        pBool := __NEW(BOOL);\n        IF pBool <> 0 THEN\n            IF Token.TokenType = JSON_TOKEN_TRUE THEN\n                pBool^ := TRUE;\n            ELSE\n                pBool^ := FALSE;\n            END_IF;\n            Result.DataType := JSON_DATA_BOOL;\n            Result.pValue := pBool;\n        END_IF;\n    \n    JSON_TOKEN_NUMBER:\n        // Check if number has decimal point or exponent\n        HasDecimal := FALSE;\n        FOR i := 0 TO Token.Length - 1 DO\n            CurrentChar := pTokenStart[i];\n            IF (CurrentChar = 46) OR (CurrentChar = 101) OR (CurrentChar = 69) THEN // . e E\n                HasDecimal := TRUE;\n                EXIT;\n            END_IF;\n        END_FOR;\n        \n        IF HasDecimal THEN\n            // Parse as REAL\n            pReal := __NEW(REAL);\n            IF pReal <> 0 THEN\n                RealValue := 0.0;\n                IsNegative := FALSE;\n                i := 0;\n                \n                // Check for negative sign\n                CurrentChar := pTokenStart[i];\n                IF CurrentChar = 45 THEN  // -\n                    IsNegative := TRUE;\n                    i := i + 1;\n                END_IF;\n                \n                // Parse integer part\n                WHILE i < Token.Length DO\n                    CurrentChar := pTokenStart[i];\n                    IF (CurrentChar >= 48) AND (CurrentChar <= 57) THEN  // 0-9\n                        RealValue := RealValue * 10.0 + TO_REAL(CurrentChar - 48);\n                        i := i + 1;\n                    ELSE\n                        EXIT;\n                    END_IF;\n                END_WHILE;\n                \n                // Parse decimal part if present\n                IF (i < Token.Length) AND (pTokenStart[i] = 46) THEN  // .\n                    i := i + 1;\n                    DecimalPart := 0.0;\n                    DecimalDivisor := 10.0;\n                    \n                    WHILE i < Token.Length DO\n                        CurrentChar := pTokenStart[i];\n                        IF (CurrentChar >= 48) AND (CurrentChar <= 57) THEN\n                            DecimalPart := DecimalPart + TO_REAL(CurrentChar - 48) / DecimalDivisor;\n                            DecimalDivisor := DecimalDivisor * 10.0;\n                            i := i + 1;\n                        ELSE\n                            EXIT;\n                        END_IF;\n                    END_WHILE;\n                    \n                    RealValue := RealValue + DecimalPart;\n                END_IF;\n                \n                // Note: Exponent parsing omitted for brevity, add if needed\n                \n                IF IsNegative THEN\n                    RealValue := -RealValue;\n                END_IF;\n                \n                pReal^ := RealValue;\n                Result.DataType := JSON_DATA_REAL;\n                Result.pValue := pReal;\n            END_IF;\n        ELSE\n            // Parse as integer (DINT)\n            pInt := __NEW(DINT);\n            IF pInt <> 0 THEN\n                IntValue := 0;\n                IsNegative := FALSE;\n                i := 0;\n                \n                // Check for negative sign\n                CurrentChar := pTokenStart[i];\n                IF CurrentChar = 45 THEN  // -\n                    IsNegative := TRUE;\n                    i := i + 1;\n                END_IF;\n                \n                // Parse digits\n                WHILE i < Token.Length DO\n                    CurrentChar := pTokenStart[i];\n                    IF (CurrentChar >= 48) AND (CurrentChar <= 57) THEN  // 0-9\n                        IntValue := IntValue * 10 + TO_DINT(CurrentChar - 48);\n                        i := i + 1;\n                    ELSE\n                        EXIT;\n                    END_IF;\n                END_WHILE;\n                \n                IF IsNegative THEN\n                    IntValue := -IntValue;\n                END_IF;\n                \n                pInt^ := IntValue;\n                Result.DataType := JSON_DATA_INT;\n                Result.pValue := pInt;\n            END_IF;\n        END_IF;\n    \n    JSON_TOKEN_STRING:\n\t\t// Allocate memory for string (length + 1 for null terminator)\n\t\tStringLen := Token.Length; \n\t\tStrLenVal := StringLen - 1; \n        pString := __NEW(BYTE, StrLenVal);\n\t\tj := 0; \n        IF pString <> 0 THEN\n            FOR i :=1 TO StringLen -2 DO//Skip the \" \n                CurrentChar := pTokenStart[i];\n                // Handle escape sequences\n                IF CurrentChar = 92 THEN  // \\ (backslash)\n\t\t\t\t\ti := i + 1; \n                    TempChar := pTokenStart[i];\n                    CASE TempChar OF\n                        110: pString[j] := 10;  // \\n -> LF\n                        116: pString[j] := 9;   // \\t -> TAB\n                        114: pString[j] := 13;  // \\r -> CR\n                        34:  pString[j] := 34;  // \\\" -> \"\n                        92:  pString[j] := 92;  // \\\\ -> \\\n                    ELSE\n                        pString[j] := TempChar;\n                    END_CASE;\n                ELSE\n                    pString[j] := CurrentChar;  // Adjust for escape handling\n                END_IF;\n\t\t\t\tj := j + 1; \n            END_FOR;\n            \n            // Add null terminator\n            pString[j] := 0;\n            \n            Result.DataType := JSON_DATA_STRING;\n            Result.pValue := pString;\n        END_IF;\n    \nELSE\n    Result.DataType := JSON_DATA_NULL;\n    Result.pValue := 0;\nEND_CASE;\n\nJsonHadlr := Result;","LineInfoPersistence":"(string)6c12f7bf-0d38-403a-9f81-0c4bb214fb91_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)FUNCTION JsonHadlr : JsonType\nVAR_INPUT\n\tpJsonString : POINTER TO BYTE;  // Pointer to JSON string bytes\n    Token : JsonToken;              // Token to parse\nEND_VAR\nVAR\n\tResult : JsonType;\n    pTokenStart : POINTER TO BYTE;\n    pReal : POINTER TO REAL;\n    pInt : POINTER TO DINT;\n    pBool : POINTER TO BOOL;\n    pString : POINTER TO BYTE;\n    i : DINT;\n    CurrentChar : BYTE;\n    StringLen : DINT;\n    IsNegative : BOOL;\n    IntValue : DINT;\n    RealValue : REAL;\n    DecimalPart : REAL;\n    DecimalDivisor : REAL;\n    HasDecimal : BOOL;\n    TempChar : BYTE;\n\tStrLenVal: DINT;\n\tj : LINT; \nEND_VAR\n","LineInfoPersistence":"(string)6c12f7bf-0d38-403a-9f81-0c4bb214fb91_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)407","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}